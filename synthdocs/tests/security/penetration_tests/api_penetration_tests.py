"""\nPenetration tests for API security.\n\nTests API endpoints for common vulnerabilities including injection attacks,\nauthentication bypass, authorization flaws, and other security issues.\n"""\n\nimport pytest\nimport asyncio\nimport json\nimport jwt\nimport requests\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch, AsyncMock\nimport base64\nimport xml.etree.ElementTree as ET\n\nfrom structured_docs_synth.delivery.api.rest_api import RestAPI\nfrom structured_docs_synth.core.exceptions import SecurityError, APIError\n\n\nclass TestAPIInjectionAttacks:\n    """Test API resistance to injection attacks."""\n    \n    @pytest.fixture\n    def api_client(self):\n        """Provide test API client."""\n        return RestAPI(test_mode=True)\n    \n    @pytest.mark.security\n    @pytest.mark.parametrize("payload", [\n        # SQL Injection\n        {"document_type": "invoice' OR '1'='1"},\n        {"search": "'; DROP TABLE documents; --"},\n        {"id": "1 UNION SELECT * FROM users"},\n        \n        # NoSQL Injection\n        {"filter": {"$ne": None}},\n        {"query": {"$where": "this.password == '123'"}},\n        \n        # Command Injection\n        {"filename": "test.pdf; rm -rf /"},\n        {"export_path": "../../etc/passwd"},\n        \n        # LDAP Injection\n        {"username": "admin*)(uid=*)"},\n        {"search": "*)(objectClass=*"}\n    ])\n    async def test_injection_prevention(self, api_client, payload):\n        """Test prevention of various injection attacks."""\n        response = await api_client.process_request(\n            endpoint="/api/v1/documents",\n            method="POST",\n            data=payload\n        )\n        \n        # Should reject or sanitize malicious input\n        assert response.status_code in [400, 403]\n        assert "invalid" in response.json().get("error", "").lower()\n        \n        # Verify no actual injection occurred\n        audit = await api_client.get_security_audit()\n        assert audit["injection_attempts_blocked"] > 0\n    \n    @pytest.mark.security\n    async def test_xxe_prevention(self, api_client):\n        """Test XML External Entity (XXE) injection prevention."""\n        xxe_payload = """\n        <?xml version="1.0" encoding="UTF-8"?>\n        <!DOCTYPE root [\n            <!ENTITY xxe SYSTEM "file:///etc/passwd">\n        ]>\n        <document>\n            <content>&xxe;</content>\n        </document>\n        """\n        \n        response = await api_client.process_request(\n            endpoint="/api/v1/import",\n            method="POST",\n            data=xxe_payload,\n            content_type="application/xml"\n        )\n        \n        assert response.status_code == 400\n        assert "xxe" not in response.text.lower()\n        assert "/etc/passwd" not in response.text\n    \n    @pytest.mark.security\n    async def test_template_injection(self, api_client):\n        """Test Server-Side Template Injection (SSTI) prevention."""\n        ssti_payloads = [\n            {"template": "{{7*7}}"},\n            {"name": "${7*7}"},\n            {"content": "<%= system('id') %>"},\n            {"format": "{{ config.items() }}"}\n        ]\n        \n        for payload in ssti_payloads:\n            response = await api_client.process_request(\n                endpoint="/api/v1/generate",\n                method="POST",\n                data=payload\n            )\n            \n            # Should not execute template code\n            assert "49" not in response.text  # 7*7\n            assert "uid=" not in response.text  # system command\n            assert "SECRET" not in response.text  # config exposure\n\n\nclass TestAPIAuthenticationBypass:\n    """Test API authentication bypass vulnerabilities."""\n    \n    @pytest.fixture\n    def secured_api(self):\n        """Provide API with authentication enabled."""\n        api = RestAPI(test_mode=True)\n        api.config.enable_auth = True\n        api.config.jwt_secret = "test-secret-key"\n        return api\n    \n    @pytest.mark.security\n    async def test_jwt_algorithm_confusion(self, secured_api):\n        """Test JWT algorithm confusion attack."""\n        # Create token with 'none' algorithm\n        token = jwt.encode(\n            {"user_id": "admin", "exp": datetime.utcnow() + timedelta(hours=1)},\n            key="",\n            algorithm="none"\n        )\n        \n        response = await secured_api.process_request(\n            endpoint="/api/v1/admin/users",\n            method="GET",\n            headers={"Authorization": f"Bearer {token}"}\n        )\n        \n        assert response.status_code == 401\n        assert "invalid token" in response.json().get("error", "").lower()\n    \n    @pytest.mark.security\n    async def test_jwt_key_confusion(self, secured_api):\n        """Test JWT key confusion attack."""\n        # Try to use public key as HMAC secret\n        fake_token = jwt.encode(\n            {"user_id": "admin", "role": "admin"},\n            key="public-key-content",\n            algorithm="HS256"\n        )\n        \n        response = await secured_api.process_request(\n            endpoint="/api/v1/admin/settings",\n            method="GET",\n            headers={"Authorization": f"Bearer {fake_token}"}\n        )\n        \n        assert response.status_code == 401\n    \n    @pytest.mark.security\n    async def test_authentication_bypass_headers(self, secured_api):\n        """Test authentication bypass via header manipulation."""\n        bypass_headers = [\n            {"X-Forwarded-For": "127.0.0.1"},\n            {"X-Real-IP": "::1"},\n            {"X-Originating-IP": "localhost"},\n            {"X-Remote-User": "admin"},\n            {"X-Authenticated-User": "admin"}\n        ]\n        \n        for headers in bypass_headers:\n            response = await secured_api.process_request(\n                endpoint="/api/v1/admin/users",\n                method="GET",\n                headers=headers\n            )\n            \n            assert response.status_code == 401\n            assert "unauthorized" in response.json().get("error", "").lower()\n    \n    @pytest.mark.security\n    async def test_session_fixation(self, secured_api):\n        """Test session fixation vulnerability."""\n        # Try to set session ID\n        fixed_session_id = "attacker-controlled-session"\n        \n        response = await secured_api.process_request(\n            endpoint="/api/v1/login",\n            method="POST",\n            data={"username": "user", "password": "pass"},\n            headers={"Cookie": f"session_id={fixed_session_id}"}\n        )\n        \n        # Should generate new session ID, not use provided one\n        if "set-cookie" in response.headers:\n            assert fixed_session_id not in response.headers["set-cookie"]\n\n\nclass TestAPIAuthorizationFlaws:\n    """Test API authorization vulnerabilities."""\n    \n    @pytest.fixture\n    def api_with_users(self):\n        """Provide API with multiple user contexts."""\n        api = RestAPI(test_mode=True)\n        api.users = {\n            "user1": {"id": "1", "role": "user", "documents": ["doc1", "doc2"]},\n            "user2": {"id": "2", "role": "user", "documents": ["doc3", "doc4"]},\n            "admin": {"id": "999", "role": "admin", "documents": []}\n        }\n        return api\n    \n    @pytest.mark.security\n    async def test_idor_vulnerability(self, api_with_users):\n        """Test Insecure Direct Object Reference (IDOR) vulnerability."""\n        # User1 trying to access User2's document\n        user1_token = api_with_users.generate_token("user1")\n        \n        response = await api_with_users.process_request(\n            endpoint="/api/v1/documents/doc3",  # Belongs to user2\n            method="GET",\n            headers={"Authorization": f"Bearer {user1_token}"}\n        )\n        \n        assert response.status_code == 403\n        assert "forbidden" in response.json().get("error", "").lower()\n    \n    @pytest.mark.security\n    async def test_privilege_escalation(self, api_with_users):\n        """Test privilege escalation vulnerability."""\n        user_token = api_with_users.generate_token("user1")\n        \n        # Try to change own role\n        escalation_attempts = [\n            {"role": "admin"},\n            {"permissions": ["admin.read", "admin.write"]},\n            {"is_admin": True}\n        ]\n        \n        for payload in escalation_attempts:\n            response = await api_with_users.process_request(\n                endpoint="/api/v1/users/1",\n                method="PATCH",\n                data=payload,\n                headers={"Authorization": f"Bearer {user_token}"}\n            )\n            \n            assert response.status_code in [403, 400]\n            \n            # Verify role didn't change\n            user_data = api_with_users.users["user1"]\n            assert user_data["role"] == "user"\n    \n    @pytest.mark.security\n    async def test_path_traversal_authorization(self, api_with_users):\n        """Test path traversal in authorization context."""\n        user_token = api_with_users.generate_token("user1")\n        \n        traversal_paths = [\n            "../admin/config",\n            "..\\..\\admin\\settings",\n            "%2e%2e%2fadmin%2fusers",\n            "documents/../../../etc/passwd"\n        ]\n        \n        for path in traversal_paths:\n            response = await api_with_users.process_request(\n                endpoint=f"/api/v1/files/{path}",\n                method="GET",\n                headers={"Authorization": f"Bearer {user_token}"}\n            )\n            \n            assert response.status_code in [400, 403, 404]\n            assert "admin" not in response.text\n            assert "passwd" not in response.text\n\n\nclass TestAPIRateLimitingAndDoS:\n    """Test API rate limiting and DoS protection."""\n    \n    @pytest.fixture\n    def rate_limited_api(self):\n        """Provide API with rate limiting enabled."""\n        api = RestAPI(test_mode=True)\n        api.config.rate_limit = 10  # 10 requests per minute\n        return api\n    \n    @pytest.mark.security\n    async def test_rate_limit_bypass(self, rate_limited_api):\n        """Test rate limit bypass attempts."""\n        # Try to bypass with different headers\n        bypass_attempts = []\n        \n        for i in range(15):\n            headers = {\n                "X-Forwarded-For": f"192.168.1.{i}",\n                "X-Real-IP": f"10.0.0.{i}",\n                "User-Agent": f"Bot{i}"\n            }\n            \n            response = await rate_limited_api.process_request(\n                endpoint="/api/v1/documents",\n                method="GET",\n                headers=headers\n            )\n            \n            bypass_attempts.append(response.status_code != 429)\n        \n        # Should still be rate limited\n        assert not all(bypass_attempts)\n    \n    @pytest.mark.security\n    async def test_resource_exhaustion(self, rate_limited_api):\n        """Test protection against resource exhaustion attacks."""\n        # Large payload attack\n        large_payload = {\n            "data": "A" * (10 * 1024 * 1024)  # 10MB\n        }\n        \n        response = await rate_limited_api.process_request(\n            endpoint="/api/v1/documents",\n            method="POST",\n            data=large_payload\n        )\n        \n        assert response.status_code == 413  # Payload too large\n        \n        # Deeply nested JSON\n        nested_json = {"a": {"b": {"c": {"d": {}}}}}\n        current = nested_json["a"]["b"]["c"]["d"]\n        for i in range(1000):\n            current["e"] = {}\n            current = current["e"]\n        \n        response = await rate_limited_api.process_request(\n            endpoint="/api/v1/parse",\n            method="POST",\n            data=nested_json\n        )\n        \n        assert response.status_code in [400, 413]\n    \n    @pytest.mark.security\n    async def test_slowloris_protection(self, rate_limited_api):\n        """Test protection against Slowloris attacks."""\n        # Simulate slow request\n        async def slow_request():\n            return await rate_limited_api.process_request(\n                endpoint="/api/v1/upload",\n                method="POST",\n                data=b"slow data",\n                chunk_size=1,  # 1 byte at a time\n                delay_between_chunks=5  # 5 seconds\n            )\n        \n        # Should timeout\n        with pytest.raises(asyncio.TimeoutError):\n            await asyncio.wait_for(slow_request(), timeout=30)\n\n\nclass TestAPICryptographicWeaknesses:\n    """Test API cryptographic vulnerabilities."""\n    \n    @pytest.fixture\n    def crypto_api(self):\n        """Provide API with cryptographic features."""\n        return RestAPI(test_mode=True)\n    \n    @pytest.mark.security\n    async def test_weak_randomness(self, crypto_api):\n        """Test for weak random number generation."""\n        tokens = []\n        \n        for _ in range(100):\n            response = await crypto_api.process_request(\n                endpoint="/api/v1/generate-token",\n                method="POST"\n            )\n            tokens.append(response.json()["token"])\n        \n        # Check for patterns or duplicates\n        assert len(set(tokens)) == len(tokens)  # All unique\n        \n        # Check entropy\n        for token in tokens:\n            assert len(token) >= 32  # Sufficient length\n            # Should use secure random\n            assert not token.isdigit()  # Not just numbers\n            assert not token.isalpha()  # Not just letters\n    \n    @pytest.mark.security\n    async def test_timing_attacks(self, crypto_api):\n        """Test for timing attack vulnerabilities."""\n        import time\n        \n        valid_token = "valid-api-token-12345"\n        invalid_tokens = [\n            "invalid-api-token-123",\n            "xnvalid-api-token-123",\n            "xxvalid-api-token-123"\n        ]\n        \n        timings = []\n        \n        for token in [valid_token] + invalid_tokens:\n            start = time.perf_counter()\n            \n            await crypto_api.process_request(\n                endpoint="/api/v1/protected",\n                method="GET",\n                headers={"X-API-Key": token}\n            )\n            \n            elapsed = time.perf_counter() - start\n            timings.append(elapsed)\n        \n        # Check that timing differences are minimal\n        max_diff = max(timings) - min(timings)\n        assert max_diff < 0.01  # Less than 10ms difference\n    \n    @pytest.mark.security\n    async def test_encryption_downgrade(self, crypto_api):\n        """Test protection against encryption downgrade attacks."""\n        # Try to force weak encryption\n        response = await crypto_api.process_request(\n            endpoint="/api/v1/encrypt",\n            method="POST",\n            data={"content": "sensitive data"},\n            headers={"X-Encryption-Algorithm": "DES"}  # Weak algorithm\n        )\n        \n        result = response.json()\n        assert result.get("algorithm") != "DES"\n        assert result.get("algorithm") in ["AES-256", "AES-128"]\n\n\nclass TestAPIBusinessLogicFlaws:\n    """Test API business logic vulnerabilities."""\n    \n    @pytest.fixture\n    def business_api(self):\n        """Provide API with business logic."""\n        api = RestAPI(test_mode=True)\n        api.credits = {"user1": 100}\n        return api\n    \n    @pytest.mark.security\n    async def test_race_condition(self, business_api):\n        """Test for race condition vulnerabilities."""\n        # Simulate concurrent requests to spend credits\n        async def spend_credits():\n            return await business_api.process_request(\n                endpoint="/api/v1/spend-credits",\n                method="POST",\n                data={"amount": 60},\n                headers={"Authorization": "Bearer user1-token"}\n            )\n        \n        # Run concurrent requests\n        results = await asyncio.gather(\n            spend_credits(),\n            spend_credits(),\n            return_exceptions=True\n        )\n        \n        # Should not allow overspending\n        success_count = sum(1 for r in results if r.status_code == 200)\n        assert success_count <= 1  # Only one should succeed\n        \n        # Check final balance\n        assert business_api.credits["user1"] >= 0\n    \n    @pytest.mark.security\n    async def test_integer_overflow(self, business_api):\n        """Test for integer overflow vulnerabilities."""\n        overflow_values = [\n            2**31 - 1,  # Max 32-bit signed\n            2**32 - 1,  # Max 32-bit unsigned\n            2**63 - 1,  # Max 64-bit signed\n            -2**31,     # Min 32-bit signed\n        ]\n        \n        for value in overflow_values:\n            response = await business_api.process_request(\n                endpoint="/api/v1/calculate",\n                method="POST",\n                data={"quantity": value, "price": value}\n            )\n            \n            # Should handle large numbers safely\n            assert response.status_code in [200, 400]\n            if response.status_code == 200:\n                result = response.json()["total"]\n                assert isinstance(result, (int, float))\n                assert result > 0  # No negative overflow\n    \n    @pytest.mark.security\n    async def test_workflow_bypass(self, business_api):\n        """Test for workflow bypass vulnerabilities."""\n        # Try to skip steps in multi-step process\n        # Skip step 1 and 2, go directly to step 3\n        response = await business_api.process_request(\n            endpoint="/api/v1/workflow/step3",\n            method="POST",\n            data={"complete": True},\n            headers={"Authorization": "Bearer user1-token"}\n        )\n        \n        assert response.status_code == 400\n        assert "previous steps not completed" in response.json().get("error", "").lower()