"""\nSecurity tests for GDPR compliance.\n\nTests security controls required for GDPR including data protection,\nprivacy by design, consent management, and cross-border data transfers.\n"""\n\nimport pytest\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any\nimport hashlib\nimport json\nfrom unittest.mock import Mock, AsyncMock, patch\n\nfrom structured_docs_synth.privacy.compliance.gdpr_enforcer import (\n    GDPREnforcer,\n    ConsentManager,\n    DataSubjectRights,\n    PrivacyByDesign,\n    DataProtectionOfficer\n)\nfrom structured_docs_synth.core.exceptions import ComplianceError, SecurityError\n\n\nclass TestGDPRDataProtection:\n    """Test GDPR data protection requirements."""\n    \n    @pytest.fixture\n    def gdpr_enforcer(self):\n        """Provide GDPR enforcer instance."""\n        return GDPREnforcer()\n    \n    @pytest.mark.security\n    def test_encryption_at_rest(self, gdpr_enforcer):\n        """Test data encryption at rest requirement."""\n        # Test data\n        personal_data = {\n            "name": "John Doe",\n            "email": "john.doe@example.com",\n            "phone": "+1234567890",\n            "address": "123 Main St, City, Country"\n        }\n        \n        # Encrypt data\n        encrypted = gdpr_enforcer.encrypt_personal_data(\n            data=personal_data,\n            purpose="storage",\n            encryption_level="high"\n        )\n        \n        assert encrypted["encrypted"] is True\n        assert encrypted["algorithm"] in ["AES-256-GCM", "ChaCha20-Poly1305"]\n        assert encrypted["data"] != personal_data\n        assert "encryption_key_id" in encrypted\n        assert encrypted["integrity_check"] is not None\n        \n        # Verify data is not readable without decryption\n        assert "John Doe" not in str(encrypted["data"])\n        assert "john.doe@example.com" not in str(encrypted["data"])\n    \n    @pytest.mark.security\n    def test_encryption_in_transit(self, gdpr_enforcer):\n        """Test data encryption in transit requirement."""\n        # Prepare data for transmission\n        data_packet = {\n            "recipient": "external_processor",\n            "data": {"user_id": "12345", "preferences": {"marketing": False}}\n        }\n        \n        # Prepare secure transmission\n        transmission = gdpr_enforcer.prepare_secure_transmission(\n            data=data_packet,\n            destination="https://processor.example.com/api",\n            protocol="TLS1.3"\n        )\n        \n        assert transmission["encrypted"] is True\n        assert transmission["protocol"] == "TLS1.3"\n        assert transmission["perfect_forward_secrecy"] is True\n        assert transmission["certificate_pinning"] is True\n        assert "session_key" in transmission\n    \n    @pytest.mark.security\n    def test_pseudonymization(self, gdpr_enforcer):\n        """Test data pseudonymization capabilities."""\n        # Original data\n        user_data = {\n            "user_id": "USR123456",\n            "name": "Jane Smith",\n            "email": "jane.smith@company.com",\n            "department": "Engineering",\n            "salary": 85000\n        }\n        \n        # Apply pseudonymization\n        pseudonymized = gdpr_enforcer.pseudonymize_data(\n            data=user_data,\n            fields_to_pseudonymize=["name", "email"],\n            reversible=True\n        )\n        \n        # Verify pseudonymization\n        assert pseudonymized["name"] != "Jane Smith"\n        assert pseudonymized["email"] != "jane.smith@company.com"\n        assert pseudonymized["department"] == "Engineering"  # Not pseudonymized\n        assert "_pseudonym_map" in pseudonymized["metadata"]\n        \n        # Verify reversibility\n        if pseudonymized["reversible"]:\n            restored = gdpr_enforcer.restore_pseudonymized_data(\n                data=pseudonymized["data"],\n                pseudonym_map=pseudonymized["metadata"]["_pseudonym_map"]\n            )\n            assert restored["name"] == "Jane Smith"\n\n\nclass TestGDPRConsentManagement:\n    """Test GDPR consent management security."""\n    \n    @pytest.fixture\n    def consent_manager(self):\n        """Provide consent manager instance."""\n        return ConsentManager()\n    \n    @pytest.mark.security\n    def test_consent_integrity(self, consent_manager):\n        """Test consent record integrity and tamper protection."""\n        # Record consent\n        consent = consent_manager.record_consent(\n            data_subject_id="DS123",\n            purpose="marketing",\n            scope=["email", "name"],\n            duration_days=365,\n            explicit=True,\n            freely_given=True\n        )\n        \n        # Verify integrity\n        assert consent["signature"] is not None\n        assert consent["timestamp"] is not None\n        assert consent["version"] == "1.0"\n        \n        # Verify tamper detection\n        tampered_consent = consent.copy()\n        tampered_consent["scope"].append("phone")  # Unauthorized modification\n        \n        with pytest.raises(SecurityError, match="Consent integrity violation"):\n            consent_manager.verify_consent_integrity(tampered_consent)\n    \n    @pytest.mark.security\n    def test_consent_withdrawal_security(self, consent_manager):\n        """Test secure consent withdrawal process."""\n        # Record initial consent\n        consent_id = consent_manager.record_consent(\n            data_subject_id="DS456",\n            purpose="analytics",\n            scope=["usage_data"]\n        )["consent_id"]\n        \n        # Withdraw consent with authentication\n        withdrawal = consent_manager.withdraw_consent(\n            consent_id=consent_id,\n            data_subject_id="DS456",\n            authentication_token="valid_token",\n            reason="no_longer_needed"\n        )\n        \n        assert withdrawal["success"] is True\n        assert withdrawal["withdrawal_timestamp"] is not None\n        assert withdrawal["data_deletion_scheduled"] is True\n        assert withdrawal["audit_logged"] is True\n        \n        # Verify consent cannot be used after withdrawal\n        with pytest.raises(ComplianceError, match="Consent withdrawn"):\n            consent_manager.validate_consent(consent_id)\n    \n    @pytest.mark.security\n    def test_consent_forgery_prevention(self, consent_manager):\n        """Test prevention of consent forgery."""\n        # Attempt to forge consent\n        forged_consent = {\n            "data_subject_id": "DS789",\n            "purpose": "everything",\n            "scope": ["all_data"],\n            "timestamp": datetime.now().isoformat(),\n            "signature": "forged_signature_12345"\n        }\n        \n        # Should detect forgery\n        with pytest.raises(SecurityError, match="Invalid consent signature"):\n            consent_manager.validate_consent_signature(forged_consent)\n\n\nclass TestGDPRDataSubjectRights:\n    """Test security of data subject rights implementation."""\n    \n    @pytest.fixture\n    def rights_manager(self):\n        """Provide data subject rights manager."""\n        return DataSubjectRights()\n    \n    @pytest.mark.security\n    def test_right_to_access_authentication(self, rights_manager):\n        """Test authentication for data access requests."""\n        # Submit access request\n        request = rights_manager.submit_access_request(\n            data_subject_id="DS001",\n            authentication={\n                "method": "two_factor",\n                "token": "123456",\n                "biometric_hash": hashlib.sha256(b"fingerprint").hexdigest()\n            }\n        )\n        \n        assert request["status"] == "pending_verification"\n        assert request["security_checks"]["authentication"] == "passed"\n        assert request["security_checks"]["rate_limiting"] == "passed"\n        \n        # Test failed authentication\n        with pytest.raises(SecurityError, match="Authentication failed"):\n            rights_manager.submit_access_request(\n                data_subject_id="DS001",\n                authentication={"method": "invalid", "token": "wrong"}\n            )\n    \n    @pytest.mark.security\n    def test_right_to_erasure_verification(self, rights_manager):\n        """Test secure erasure verification process."""\n        # Request erasure\n        erasure_request = rights_manager.request_erasure(\n            data_subject_id="DS002",\n            authentication_token="valid_token",\n            erasure_scope="all_personal_data"\n        )\n        \n        # Verify multi-step verification\n        assert erasure_request["verification_required"] is True\n        assert erasure_request["verification_methods"] == ["email", "sms"]\n        \n        # Complete verification\n        erasure_result = rights_manager.execute_erasure(\n            request_id=erasure_request["request_id"],\n            verification_codes={"email": "ABC123", "sms": "456789"}\n        )\n        \n        assert erasure_result["status"] == "completed"\n        assert erasure_result["data_removed"]["database"] is True\n        assert erasure_result["data_removed"]["backups_scheduled"] is True\n        assert erasure_result["cryptographic_erasure"] is True\n    \n    @pytest.mark.security\n    def test_data_portability_security(self, rights_manager):\n        """Test secure data portability implementation."""\n        # Request data export\n        export_request = rights_manager.request_data_export(\n            data_subject_id="DS003",\n            format="encrypted_json",\n            include_derived_data=False\n        )\n        \n        # Verify security measures\n        assert export_request["encryption"]["enabled"] is True\n        assert export_request["encryption"]["algorithm"] == "AES-256-GCM"\n        assert export_request["access_control"]["password_protected"] is True\n        assert export_request["access_control"]["time_limited"] is True\n        assert export_request["access_control"]["download_limit"] == 3\n        \n        # Verify secure download\n        download = rights_manager.download_exported_data(\n            export_id=export_request["export_id"],\n            access_token=export_request["access_token"]\n        )\n        \n        assert download["integrity_check"] is not None\n        assert download["audit_logged"] is True\n\n\nclass TestGDPRPrivacyByDesign:\n    """Test Privacy by Design implementation."""\n    \n    @pytest.fixture\n    def privacy_by_design(self):\n        """Provide Privacy by Design enforcer."""\n        return PrivacyByDesign()\n    \n    @pytest.mark.security\n    def test_data_minimization_enforcement(self, privacy_by_design):\n        """Test data minimization principle enforcement."""\n        # Define data collection request\n        collection_request = {\n            "purpose": "user_registration",\n            "requested_fields": [\n                "email", "password", "name", "phone", "address",\n                "date_of_birth", "social_security_number", "income"\n            ]\n        }\n        \n        # Apply data minimization\n        minimized = privacy_by_design.apply_data_minimization(\n            request=collection_request,\n            purpose_requirements={\n                "user_registration": ["email", "password", "name"]\n            }\n        )\n        \n        assert len(minimized["allowed_fields"]) == 3\n        assert "social_security_number" not in minimized["allowed_fields"]\n        assert "income" not in minimized["allowed_fields"]\n        assert minimized["rejected_fields"] == [\n            "phone", "address", "date_of_birth", \n            "social_security_number", "income"\n        ]\n    \n    @pytest.mark.security\n    def test_privacy_default_settings(self, privacy_by_design):\n        """Test privacy by default implementation."""\n        # Create new user account\n        user_settings = privacy_by_design.create_default_privacy_settings(\n            user_id="NEW_USER_123"\n        )\n        \n        # Verify restrictive defaults\n        assert user_settings["data_sharing"]["third_parties"] is False\n        assert user_settings["data_sharing"]["analytics"] is False\n        assert user_settings["data_sharing"]["marketing"] is False\n        assert user_settings["visibility"]["profile"] == "private"\n        assert user_settings["visibility"]["activity"] == "self_only"\n        assert user_settings["data_retention"]["period"] == "minimum_required"\n    \n    @pytest.mark.security\n    def test_purpose_limitation_enforcement(self, privacy_by_design):\n        """Test purpose limitation principle."""\n        # Store data with specific purpose\n        storage_record = privacy_by_design.store_with_purpose(\n            data={"email": "user@example.com", "purchase_history": []},\n            original_purpose="order_fulfillment",\n            retention_period=90\n        )\n        \n        # Attempt to use for different purpose\n        with pytest.raises(ComplianceError, match="Purpose limitation violation"):\n            privacy_by_design.access_data(\n                record_id=storage_record["id"],\n                requested_purpose="marketing_analysis"\n            )\n        \n        # Verify legitimate access\n        legitimate_access = privacy_by_design.access_data(\n            record_id=storage_record["id"],\n            requested_purpose="order_fulfillment"\n        )\n        \n        assert legitimate_access["access_granted"] is True\n        assert legitimate_access["audit_logged"] is True\n\n\nclass TestGDPRCrossBorderTransfers:\n    """Test GDPR cross-border data transfer security."""\n    \n    @pytest.fixture\n    def transfer_manager(self):\n        """Provide cross-border transfer manager."""\n        return gdpr_enforcer.CrossBorderTransferManager()\n    \n    @pytest.mark.security\n    def test_adequacy_decision_verification(self, transfer_manager):\n        """Test adequacy decision verification for data transfers."""\n        # Test transfer to adequate country\n        adequate_transfer = transfer_manager.validate_transfer(\n            source_country="DE",  # Germany (EU)\n            destination_country="JP",  # Japan (Adequate)\n            data_categories=["personal", "financial"]\n        )\n        \n        assert adequate_transfer["allowed"] is True\n        assert adequate_transfer["basis"] == "adequacy_decision"\n        assert adequate_transfer["additional_safeguards_required"] is False\n        \n        # Test transfer to non-adequate country\n        non_adequate_transfer = transfer_manager.validate_transfer(\n            source_country="FR",  # France (EU)\n            destination_country="US",  # USA (No adequacy)\n            data_categories=["personal", "health"]\n        )\n        \n        assert non_adequate_transfer["allowed"] is False\n        assert non_adequate_transfer["alternatives"] == [\n            "standard_contractual_clauses",\n            "binding_corporate_rules",\n            "explicit_consent"\n        ]\n    \n    @pytest.mark.security\n    def test_standard_contractual_clauses(self, transfer_manager):\n        """Test SCC implementation for transfers."""\n        # Implement transfer with SCCs\n        scc_transfer = transfer_manager.implement_scc_transfer(\n            source_entity="EU_Company_GmbH",\n            destination_entity="US_Processor_Inc",\n            scc_version="2021",\n            data_categories=["personal", "behavioral"],\n            security_measures={\n                "encryption": "AES-256",\n                "access_control": "role_based",\n                "audit_logging": True\n            }\n        )\n        \n        assert scc_transfer["contract_valid"] is True\n        assert scc_transfer["security_assessment"]["passed"] is True\n        assert scc_transfer["supplementary_measures"]["required"] is True\n        assert "encryption_in_transit" in scc_transfer["supplementary_measures"]["implemented"]\n    \n    @pytest.mark.security\n    def test_data_localization_enforcement(self, transfer_manager):\n        """Test data localization requirements."""\n        # Verify data remains in EU\n        localization_check = transfer_manager.verify_data_location(\n            data_id="GDPR_SENSITIVE_001",\n            allowed_regions=["EU", "EEA"]\n        )\n        \n        assert localization_check["compliant"] is True\n        assert localization_check["current_location"] in ["DE", "FR", "NL"]\n        assert localization_check["replication_locations"] == ["DE", "FR"]\n        \n        # Test violation detection\n        violation = transfer_manager.detect_location_violation(\n            data_id="GDPR_SENSITIVE_002",\n            detected_location="US-EAST-1"\n        )\n        \n        assert violation["violation_detected"] is True\n        assert violation["immediate_action"] == "block_access"\n        assert violation["remediation"] == "migrate_to_eu_region"\n\n\nclass TestGDPRBreachNotification:\n    """Test GDPR breach notification security."""\n    \n    @pytest.fixture\n    def breach_manager(self):\n        """Provide breach notification manager."""\n        return gdpr_enforcer.BreachNotificationManager()\n    \n    @pytest.mark.security\n    def test_breach_detection_and_assessment(self, breach_manager):\n        """Test breach detection and risk assessment."""\n        # Detect potential breach\n        breach_indicator = {\n            "event_type": "unauthorized_access",\n            "affected_systems": ["customer_database", "payment_processor"],\n            "timestamp": datetime.now(),\n            "source_ip": "suspicious_ip",\n            "data_accessed": "unknown"\n        }\n        \n        assessment = breach_manager.assess_breach(breach_indicator)\n        \n        assert assessment["severity"] == "high"\n        assert assessment["notification_required"] is True\n        assert assessment["deadline_hours"] == 72\n        assert assessment["affected_data_categories"] == [\n            "personal", "financial", "potentially_sensitive"\n        ]\n        assert assessment["immediate_actions"] == [\n            "isolate_affected_systems",\n            "preserve_evidence",\n            "begin_investigation"\n        ]\n    \n    @pytest.mark.security\n    def test_secure_breach_notification(self, breach_manager):\n        """Test secure breach notification process."""\n        # Create breach notification\n        notification = breach_manager.create_notification(\n            breach_id="BREACH_2024_001",\n            affected_individuals=5000,\n            data_categories=["name", "email", "payment_card"],\n            risk_level="high"\n        )\n        \n        # Verify secure transmission to authorities\n        dpa_notification = notification["dpa_notification"]\n        assert dpa_notification["encrypted"] is True\n        assert dpa_notification["signed"] is True\n        assert dpa_notification["delivery_method"] == "secure_portal"\n        assert dpa_notification["confirmation_required"] is True\n        \n        # Verify individual notifications\n        individual_notification = notification["individual_notification"]\n        assert individual_notification["method"] == "encrypted_email"\n        assert individual_notification["includes_guidance"] is True\n        assert individual_notification["support_contact"] is not None\n\n\nif __name__ == "__main__":\n    pytest.main(["-v", "-m", "security", __file__])