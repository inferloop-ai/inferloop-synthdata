"""\nPrometheus exporter for security metrics.\n\nMonitors and exposes security-related metrics including authentication,\nauthorization, threat detection, and vulnerability assessments.\n"""\n\nimport asyncio\nimport logging\nimport hashlib\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Optional, Set\nfrom enum import Enum\nimport ipaddress\n\nfrom prometheus_client import (\n    Counter, Gauge, Histogram, Summary,\n    start_http_server, CollectorRegistry\n)\nfrom prometheus_client.core import GaugeMetricFamily, CounterMetricFamily\n\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass ThreatLevel(Enum):\n    """Threat level classifications."""\n    LOW = "low"\n    MEDIUM = "medium"\n    HIGH = "high"\n    CRITICAL = "critical"\n\n\nclass AttackType(Enum):\n    """Types of security attacks."""\n    BRUTE_FORCE = "brute_force"\n    SQL_INJECTION = "sql_injection"\n    XSS = "xss"\n    CSRF = "csrf"\n    DDoS = "ddos"\n    PRIVILEGE_ESCALATION = "privilege_escalation"\n    DATA_EXFILTRATION = "data_exfiltration"\n    MALWARE = "malware"\n\n\n# Authentication metrics\nauth_attempts = Counter(\n    'security_auth_attempts_total',\n    'Total authentication attempts',\n    ['method', 'result']  # method: password, mfa, oauth; result: success, failure\n)\n\nauth_failures = Counter(\n    'security_auth_failures_total',\n    'Total authentication failures',\n    ['method', 'reason']  # reason: invalid_credentials, locked, expired\n)\n\nactive_sessions = Gauge(\n    'security_active_sessions',\n    'Number of active user sessions',\n    ['session_type']  # web, api, cli\n)\n\npassword_strength = Histogram(\n    'security_password_strength_score',\n    'Password strength scores',\n    buckets=(0, 20, 40, 60, 80, 100)\n)\n\n# Authorization metrics\naccess_denied = Counter(\n    'security_access_denied_total',\n    'Total access denied events',\n    ['resource', 'action', 'reason']\n)\n\nprivilege_changes = Counter(\n    'security_privilege_changes_total',\n    'Total privilege/role changes',\n    ['change_type', 'role']  # change_type: grant, revoke, escalate\n)\n\n# Threat detection metrics\nthreat_detections = Counter(\n    'security_threat_detections_total',\n    'Total threat detections',\n    ['threat_type', 'severity', 'source']\n)\n\nblocked_ips = Gauge(\n    'security_blocked_ips_count',\n    'Number of blocked IP addresses',\n    ['block_reason']\n)\n\nsuspicious_activities = Counter(\n    'security_suspicious_activities_total',\n    'Total suspicious activities detected',\n    ['activity_type', 'risk_level']\n)\n\n# Vulnerability metrics\nvulnerabilities_found = Gauge(\n    'security_vulnerabilities_count',\n    'Number of known vulnerabilities',\n    ['severity', 'category']  # category: application, infrastructure, configuration\n)\n\npatch_status = Gauge(\n    'security_patch_status',\n    'System patch status (1=patched, 0=unpatched)',\n    ['component', 'severity']\n)\n\n# Encryption metrics\nencryption_operations = Counter(\n    'security_encryption_operations_total',\n    'Total encryption/decryption operations',\n    ['operation', 'algorithm']  # operation: encrypt, decrypt\n)\n\nssl_certificate_expiry = Gauge(\n    'security_ssl_certificate_expiry_days',\n    'Days until SSL certificate expiry',\n    ['domain', 'issuer']\n)\n\n# Security scanning metrics\nsecurity_scans = Counter(\n    'security_scans_total',\n    'Total security scans performed',\n    ['scan_type', 'status']  # scan_type: vulnerability, malware, compliance\n)\n\nscan_findings = Histogram(\n    'security_scan_findings_count',\n    'Number of findings per scan',\n    ['scan_type', 'severity'],\n    buckets=(0, 1, 5, 10, 25, 50, 100, 250, 500)\n)\n\n# Incident response metrics\nsecurity_incidents = Counter(\n    'security_incidents_total',\n    'Total security incidents',\n    ['incident_type', 'severity', 'status']\n)\n\nincident_response_time = Histogram(\n    'security_incident_response_time_seconds',\n    'Time to respond to security incidents',\n    ['incident_type', 'severity'],\n    buckets=(60, 300, 900, 1800, 3600, 7200, 14400, 28800)  # 1min to 8hrs\n)\n\n# Data protection metrics\ndata_access_violations = Counter(\n    'security_data_access_violations_total',\n    'Total data access violations',\n    ['data_type', 'violation_type']\n)\n\ndata_leakage_prevented = Counter(\n    'security_data_leakage_prevented_total',\n    'Total data leakage attempts prevented',\n    ['data_type', 'prevention_method']\n)\n\n\nclass SecurityMetricsCollector:\n    """Collector for security-specific metrics."""\n    \n    def __init__(self):\n        self.blocked_ips: Set[str] = set()\n        self.active_threats: Dict[str, Dict] = {}\n        self.vulnerability_db: Dict[str, List[Dict]] = {}\n        self.incident_tracker: Dict[str, Dict] = {}\n        self.failed_login_tracker: Dict[str, List[datetime]] = {}\n        self.start_time = datetime.now()\n    \n    def record_auth_attempt(self, method: str, success: bool, reason: str = None):\n        """Record authentication attempt."""\n        result = 'success' if success else 'failure'\n        auth_attempts.labels(method=method, result=result).inc()\n        \n        if not success and reason:\n            auth_failures.labels(method=method, reason=reason).inc()\n    \n    def track_failed_login(self, username: str, ip_address: str):\n        """Track failed login attempts for brute force detection."""\n        key = f"{username}:{ip_address}"\n        if key not in self.failed_login_tracker:\n            self.failed_login_tracker[key] = []\n        \n        self.failed_login_tracker[key].append(datetime.now())\n        \n        # Check for brute force (5 failures in 5 minutes)\n        recent_failures = [\n            t for t in self.failed_login_tracker[key]\n            if (datetime.now() - t).seconds < 300\n        ]\n        \n        if len(recent_failures) >= 5:\n            self.detect_threat(\n                threat_type=AttackType.BRUTE_FORCE.value,\n                severity=ThreatLevel.HIGH.value,\n                source=ip_address,\n                details={'username': username, 'attempts': len(recent_failures)}\n            )\n            self.block_ip(ip_address, 'brute_force')\n    \n    def update_active_sessions(self, session_type: str, count: int):\n        """Update active session count."""\n        active_sessions.labels(session_type=session_type).set(count)\n    \n    def record_password_strength(self, score: float):\n        """Record password strength score (0-100)."""\n        password_strength.observe(score)\n    \n    def record_access_denied(self, resource: str, action: str, reason: str):\n        """Record access denied event."""\n        access_denied.labels(\n            resource=resource,\n            action=action,\n            reason=reason\n        ).inc()\n    \n    def record_privilege_change(self, change_type: str, role: str):\n        """Record privilege/role change."""\n        privilege_changes.labels(\n            change_type=change_type,\n            role=role\n        ).inc()\n    \n    def detect_threat(self, threat_type: str, severity: str, source: str, \n                     details: Dict[str, Any] = None):\n        """Record threat detection."""\n        threat_detections.labels(\n            threat_type=threat_type,\n            severity=severity,\n            source=source\n        ).inc()\n        \n        # Track active threats\n        threat_id = hashlib.md5(f"{threat_type}:{source}:{time.time()}".encode()).hexdigest()\n        self.active_threats[threat_id] = {\n            'type': threat_type,\n            'severity': severity,\n            'source': source,\n            'detected_at': datetime.now(),\n            'details': details or {}\n        }\n        \n        # Auto-block critical threats\n        if severity == ThreatLevel.CRITICAL.value and self._is_valid_ip(source):\n            self.block_ip(source, threat_type)\n    \n    def block_ip(self, ip_address: str, reason: str):\n        """Block an IP address."""\n        if self._is_valid_ip(ip_address):\n            self.blocked_ips.add(ip_address)\n            blocked_ips.labels(block_reason=reason).inc()\n            logger.warning(f"Blocked IP {ip_address} for {reason}")\n    \n    def unblock_ip(self, ip_address: str, reason: str):\n        """Unblock an IP address."""\n        if ip_address in self.blocked_ips:\n            self.blocked_ips.remove(ip_address)\n            blocked_ips.labels(block_reason=reason).dec()\n    \n    def record_suspicious_activity(self, activity_type: str, risk_level: str):\n        """Record suspicious activity."""\n        suspicious_activities.labels(\n            activity_type=activity_type,\n            risk_level=risk_level\n        ).inc()\n    \n    def update_vulnerabilities(self, component: str, vulnerabilities: List[Dict[str, Any]]):\n        """Update vulnerability database."""\n        self.vulnerability_db[component] = vulnerabilities\n        \n        # Update metrics\n        severity_counts = {'low': 0, 'medium': 0, 'high': 0, 'critical': 0}\n        for vuln in vulnerabilities:\n            severity = vuln.get('severity', 'low')\n            severity_counts[severity] += 1\n        \n        for severity, count in severity_counts.items():\n            vulnerabilities_found.labels(\n                severity=severity,\n                category=component\n            ).set(count)\n    \n    def update_patch_status(self, component: str, severity: str, is_patched: bool):\n        """Update patch status."""\n        patch_status.labels(\n            component=component,\n            severity=severity\n        ).set(1 if is_patched else 0)\n    \n    def record_encryption_operation(self, operation: str, algorithm: str):\n        """Record encryption operation."""\n        encryption_operations.labels(\n            operation=operation,\n            algorithm=algorithm\n        ).inc()\n    \n    def update_ssl_certificate(self, domain: str, issuer: str, expiry_date: datetime):\n        """Update SSL certificate expiry."""\n        days_until_expiry = (expiry_date - datetime.now()).days\n        ssl_certificate_expiry.labels(\n            domain=domain,\n            issuer=issuer\n        ).set(days_until_expiry)\n    \n    def record_security_scan(self, scan_type: str, status: str, findings: List[Dict]):\n        """Record security scan results."""\n        security_scans.labels(\n            scan_type=scan_type,\n            status=status\n        ).inc()\n        \n        # Count findings by severity\n        severity_counts = {'low': 0, 'medium': 0, 'high': 0, 'critical': 0}\n        for finding in findings:\n            severity = finding.get('severity', 'low')\n            severity_counts[severity] += 1\n        \n        for severity, count in severity_counts.items():\n            if count > 0:\n                scan_findings.labels(\n                    scan_type=scan_type,\n                    severity=severity\n                ).observe(count)\n    \n    def create_incident(self, incident_type: str, severity: str, description: str) -> str:\n        """Create security incident."""\n        incident_id = hashlib.md5(\n            f"{incident_type}:{datetime.now().isoformat()}".encode()\n        ).hexdigest()[:8]\n        \n        self.incident_tracker[incident_id] = {\n            'type': incident_type,\n            'severity': severity,\n            'description': description,\n            'created_at': datetime.now(),\n            'status': 'open',\n            'response_start': None,\n            'resolved_at': None\n        }\n        \n        security_incidents.labels(\n            incident_type=incident_type,\n            severity=severity,\n            status='open'\n        ).inc()\n        \n        return incident_id\n    \n    def update_incident(self, incident_id: str, status: str, response_started: bool = False):\n        """Update incident status."""\n        if incident_id in self.incident_tracker:\n            incident = self.incident_tracker[incident_id]\n            old_status = incident['status']\n            incident['status'] = status\n            \n            if response_started and not incident['response_start']:\n                incident['response_start'] = datetime.now()\n                response_time = (incident['response_start'] - incident['created_at']).seconds\n                incident_response_time.labels(\n                    incident_type=incident['type'],\n                    severity=incident['severity']\n                ).observe(response_time)\n            \n            if status == 'resolved':\n                incident['resolved_at'] = datetime.now()\n            \n            # Update metrics\n            security_incidents.labels(\n                incident_type=incident['type'],\n                severity=incident['severity'],\n                status=old_status\n            ).dec()\n            \n            security_incidents.labels(\n                incident_type=incident['type'],\n                severity=incident['severity'],\n                status=status\n            ).inc()\n    \n    def record_data_violation(self, data_type: str, violation_type: str):\n        """Record data access violation."""\n        data_access_violations.labels(\n            data_type=data_type,\n            violation_type=violation_type\n        ).inc()\n    \n    def record_data_leakage_prevented(self, data_type: str, prevention_method: str):\n        """Record prevented data leakage."""\n        data_leakage_prevented.labels(\n            data_type=data_type,\n            prevention_method=prevention_method\n        ).inc()\n    \n    def _is_valid_ip(self, ip_str: str) -> bool:\n        """Check if string is valid IP address."""\n        try:\n            ipaddress.ip_address(ip_str)\n            return True\n        except ValueError:\n            return False\n    \n    def collect(self):\n        """Collect custom metrics."""\n        # Active threats summary\n        threat_counts = {}\n        for threat in self.active_threats.values():\n            key = f"{threat['type']}:{threat['severity']}"\n            threat_counts[key] = threat_counts.get(key, 0) + 1\n        \n        for key, count in threat_counts.items():\n            threat_type, severity = key.split(':')\n            yield GaugeMetricFamily(\n                'security_active_threats_count',\n                'Number of active threats',\n                value=count,\n                labels={'threat_type': threat_type, 'severity': severity}\n            )\n        \n        # Security score calculation\n        score = self._calculate_security_score()\n        yield GaugeMetricFamily(\n            'security_score_percent',\n            'Overall security score',\n            value=score\n        )\n        \n        # Mean time to respond (MTTR)\n        resolved_incidents = [\n            i for i in self.incident_tracker.values()\n            if i['status'] == 'resolved' and i['response_start']\n        ]\n        \n        if resolved_incidents:\n            total_response_time = sum(\n                (i['response_start'] - i['created_at']).seconds\n                for i in resolved_incidents\n            )\n            mttr = total_response_time / len(resolved_incidents)\n            \n            yield GaugeMetricFamily(\n                'security_mttr_seconds',\n                'Mean time to respond to incidents',\n                value=mttr\n            )\n    \n    def _calculate_security_score(self) -> float:\n        """Calculate overall security score (0-100)."""\n        score = 100.0\n        \n        # Deduct for active threats\n        critical_threats = sum(1 for t in self.active_threats.values() \n                             if t['severity'] == ThreatLevel.CRITICAL.value)\n        high_threats = sum(1 for t in self.active_threats.values() \n                          if t['severity'] == ThreatLevel.HIGH.value)\n        \n        score -= (critical_threats * 10)\n        score -= (high_threats * 5)\n        \n        # Deduct for unpatched vulnerabilities\n        total_vulns = sum(len(vulns) for vulns in self.vulnerability_db.values())\n        score -= min(total_vulns * 2, 30)\n        \n        # Deduct for open incidents\n        open_incidents = sum(1 for i in self.incident_tracker.values() \n                           if i['status'] == 'open')\n        score -= (open_incidents * 3)\n        \n        return max(0, score)\n\n\nclass SecurityMetricsExporter:\n    """Main exporter for security metrics."""\n    \n    def __init__(self, port: int = 9092):\n        self.port = port\n        self.collector = SecurityMetricsCollector()\n        self.registry = CollectorRegistry()\n        self.registry.register(self.collector)\n        self.running = False\n    \n    async def start(self):\n        """Start the metrics exporter."""\n        try:\n            # Start HTTP server\n            start_http_server(self.port, registry=self.registry)\n            logger.info(f"Security Metrics Exporter started on port {self.port}")\n            \n            self.running = True\n            \n            # Start background tasks\n            await asyncio.gather(\n                self._monitor_threats(),\n                self._cleanup_old_data(),\n                self._simulate_security_events()  # Remove in production\n            )\n            \n        except Exception as e:\n            logger.error(f"Failed to start exporter: {e}")\n            raise\n    \n    async def _monitor_threats(self):\n        """Monitor and update threat status."""\n        while self.running:\n            try:\n                # Clean up old threats (older than 24 hours)\n                cutoff_time = datetime.now() - timedelta(hours=24)\n                old_threats = [\n                    tid for tid, threat in self.collector.active_threats.items()\n                    if threat['detected_at'] < cutoff_time\n                ]\n                \n                for threat_id in old_threats:\n                    del self.collector.active_threats[threat_id]\n                \n                # Clean up failed login tracker\n                for key in list(self.collector.failed_login_tracker.keys()):\n                    self.collector.failed_login_tracker[key] = [\n                        t for t in self.collector.failed_login_tracker[key]\n                        if (datetime.now() - t).seconds < 3600  # Keep last hour\n                    ]\n                    \n                    if not self.collector.failed_login_tracker[key]:\n                        del self.collector.failed_login_tracker[key]\n                \n            except Exception as e:\n                logger.error(f"Error monitoring threats: {e}")\n            \n            await asyncio.sleep(60)  # Check every minute\n    \n    async def _cleanup_old_data(self):\n        """Clean up old tracking data."""\n        while self.running:\n            try:\n                # Clean up resolved incidents older than 7 days\n                cutoff_time = datetime.now() - timedelta(days=7)\n                old_incidents = [\n                    iid for iid, incident in self.collector.incident_tracker.items()\n                    if incident['status'] == 'resolved' and \n                    incident.get('resolved_at', datetime.now()) < cutoff_time\n                ]\n                \n                for incident_id in old_incidents:\n                    del self.collector.incident_tracker[incident_id]\n                \n            except Exception as e:\n                logger.error(f"Error in cleanup: {e}")\n            \n            await asyncio.sleep(3600)  # Clean up hourly\n    \n    async def _simulate_security_events(self):\n        """Simulate security events for testing."""\n        import random\n        \n        while self.running:\n            try:\n                # Simulate authentication attempts\n                if random.random() > 0.7:\n                    success = random.random() > 0.2\n                    self.collector.record_auth_attempt(\n                        method=random.choice(['password', 'mfa', 'oauth']),\n                        success=success,\n                        reason=None if success else random.choice(['invalid_credentials', 'locked'])\n                    )\n                \n                # Simulate threats\n                if random.random() > 0.95:\n                    self.collector.detect_threat(\n                        threat_type=random.choice(list(AttackType)).value,\n                        severity=random.choice(list(ThreatLevel)).value,\n                        source=f"192.168.{random.randint(1,255)}.{random.randint(1,255)}"\n                    )\n                \n                # Simulate suspicious activities\n                if random.random() > 0.9:\n                    self.collector.record_suspicious_activity(\n                        activity_type=random.choice(['unusual_login_time', 'data_download_spike', 'permission_probe']),\n                        risk_level=random.choice(['low', 'medium', 'high'])\n                    )\n                \n            except Exception as e:\n                logger.error(f"Error in simulation: {e}")\n            \n            await asyncio.sleep(5)\n    \n    def stop(self):\n        """Stop the exporter."""\n        self.running = False\n        logger.info("Security Metrics Exporter stopped")\n\n\n# Example usage\nif __name__ == "__main__":\n    async def main():\n        exporter = SecurityMetricsExporter(port=9092)\n        \n        # Initialize with some data\n        exporter.collector.update_vulnerabilities(\n            'web_application',\n            [\n                {'severity': 'high', 'cve': 'CVE-2024-1234'},\n                {'severity': 'medium', 'cve': 'CVE-2024-5678'}\n            ]\n        )\n        \n        exporter.collector.update_ssl_certificate(\n            'example.com',\n            'Let\'s Encrypt',\n            datetime.now() + timedelta(days=30)\n        )\n        \n        await exporter.start()\n    \n    asyncio.run(main())